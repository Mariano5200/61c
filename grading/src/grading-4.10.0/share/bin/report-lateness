#!/usr/bin/env perl
# -*- mode: Perl;-*-
# Version @VERSION@
# See the file COPYING in the main distribution directory for copyright notice.

unshift (@INC, '@LIBDIR@');
require "GradingBase.pl";
CmndLine ("aAEd:w:sX", 1, 100);
require "GradingCommon.pl";
require "TestingCommon.pl";

@assgn = @ARGV;

if (defined ($opt_d) && $#ARGV > 0
    or (defined ($opt_d) || defined ($opt_a) 
        || defined ($opt_A) || defined($opt_E))
       && defined ($opt_s)
    or defined ($opt_a) + defined ($opt_A) + defined ($opt_E) > 1) {
    Usage ();
}

if (defined ($opt_d) && ! defined (ToTime ($opt_d))) {
    Fatal ("Invalid time/date format: $opt_d.");
}

%due = %ASSGN_DUE;
if ($opt_d) {
    $due{$assgn[0]} = ToTime ($opt_d);
}

for $assgn (@assgn) {
    if (! AssignmentExists ($assgn)) {
	Fatal ("Assignment $assgn does not exist.");
    }
}

if ($opt_w) {
    if ($opt_w !~ /^(\d+)(,\d+)*$/) {
	Fatal ("Invalid format for lateness waivers.");
    }
    @waive = split(',', $opt_w);
} else {
    @waive = (0);
}
    

# Usage: formatTime (TIME)
#    Convert a UNIX time to a printable string in human format.
sub formatTime {
    @time = localtime (shift);
    return sprintf ("%d/%d@%02d:%02d", $time[4]+1, $time[3], $time[2], 
		    $time[1]);
}

# Usage: readTimesForAssign (ASSGN) 
#    Return a "lateness report": a reference to a hash that maps
#    logins to references to lists of items of the form TX, where T is
#    a timestamp and X is either the letter 'S' (successful
#    submission) or 'F' (failing submission).  There will be one such
#    item for each submission of the given assignment, ASSGN, for a
#    given login.  
sub readTimesForAssign { 
    my $assgn = shift; 
    my ($login, $timestamp, $subm, $list);

    my $late = { };

    foreach $subm (GLOB ("$SUBMISSION_DIR/$assgn/*")) {
	if (($basename, $login, $timestamp) 
	    = ($subm =~ m{ .*/(([-a-zA-Z0-9_.]+)\.([0-9]+))$ }x)) {
	    if (-e "$LOG_DIR/$assgn/ok/$basename") {
	        $suffix = "S";
	    } elsif (-e "$LOG_DIR/$assgn/failed/$basename") {
		$suffix = "F";
	    } else {
		$suffix = "?";
	    }
	    $$late{$login} = $$late{$login} || [];
	    push (@{$$late{$login}}, $timestamp . $suffix);
	}
    }

    foreach $list (values %$late) {
	@$list = sort (@$list);
    }

    return $late;
}

# Usage: lateness $assgn $login $time \$waive
#   Given that assignment ASSGN was turned in at TIME, the total lateness (in 
#   hours) for LOGIN, adjusted by exceptions, if applicable.  If $$WAIVE > 0,
#   reduce any positive lateness by up to that amount, reducing $$WAIVE 
#   accordingly.
sub lateness {
    my ($assgn, $login, $time, $waive) = @_;
    my $key = "$assgn/$login";
    my $lateness = 
       ($time - ($deadlineException{"$assgn/$login"} || $due{$assgn})) / 3600;
    if ($$waive > 0) {
	my $waiver = $$waive > $lateness ? $lateness : $$waive;
	$$waive -= $waiver;
	$lateness -= $waiver;
    }
    return $lateness;
}
    

# Usage: allLogins %LATEREPORTS
#   Given a hash mapping assignment names to late reports (see 
#   readTimesForAssign, return a sorted list of all logins mentioned in 
#   any of the reports.
sub allLogins {
    my $reports = shift;
    my (%logins, $rpt, $login);
    foreach $rpt (values %$reports) {
	foreach $login (keys %$rpt) {
	    $logins{$login} = 1;
	}
    }
    return sort (keys %logins);
}

%printed_type = ( "S" => "+", "F" => "-", "?" => "" );

# Usage: report_a \%LATEREPORTS \@ASSGNS $OPTION
#   Given a hash mapping assignment names in @ASSGNS to late reports (see 
#   readTimesForAssign), print a report to STDOUT in -a form if $OPTION is 1,
#   -A form, if $OPTION is 0, and -E form if $OPTION is 2.
sub report_a {
    my $reports = shift;
    my $assgns = shift;
    my $option = shift;
    my ($assgn, $login, $item, $timestamp, $time, $type, $subms, $lateness);
    my ($firstAssgn, $first);
    my (@waivers, $waiver, $waiver0);

    foreach $login (allLogins ($reports)) {
	$firstAssgn = 1;
	@waivers = @waive;
	$waiver = 0;

	foreach $assgn (@$assgns) {
	    $waiver += (shift @waivers);
	    $waiver0 = $waiver;
	    $report = $$reports{$assgn};
	    $subms = $$report{$login};
	    next if (! defined ($subms) or $#{$subms} < 0);
	    $first = 1;

            if ($option < 2) {
                $waiver = $waiver0;
                ($timestamp) = ($$subms[$#{$subms}] =~ /^(.*)[SF?]/);
                $time = TimeStampToTime ($timestamp);
                if (lateness ($assgn, $login, $time, \$waiver) <= 0) {
                    next;
                }
            }
                
	    foreach (@$subms) {
		($timestamp, $type) = /^(.*)([SF?])/;
		$time = TimeStampToTime ($timestamp);
		$waiver = $waiver0;
		$lateness = lateness ($assgn, $login, $time, \$waiver);
		if ($option != 1 or $lateness > 0) {
		    if ($firstAssgn) {
			print STDOUT "$login:\n";
			$firstAssgn = 0;
		    }
		    if ($first) {
			print STDOUT "  $assgn: ";
			$first = 0;
		    } else {
			print STDOUT ", ";
		    } 
		    if ($lateness > 0) {
			printf STDOUT "%s%s (+%3.1f)", formatTime ($time), 
			              $printed_type{$type}, $lateness;
		    } else {
			printf STDOUT "%s%s", formatTime ($time), 
			              $printed_type{$type};
		    }
		}
	    }
	    if (! $first) {
		print STDOUT "\n";
	    }
	}
    }
}

# Usage: report_s \%LATEREPORTS \@ASSGNS
#   Given a hash mapping assignment names in @ASSGNS to late reports (see 
#   readTimesForAssign), print a report to STDOUT in -s format 
#   of total late times
sub report_s {
    my $reports = shift;
    my $assgns = shift;
    my ($login, $assgn, $sum, $time, $timestamp, $lateness);
    my (@waivers, $waiver);

    foreach $login (allLogins ($reports)) {
	$sum = 0;
	@waivers = @waive;
	$waiver = 0;
	
	foreach $assgn (@$assgns) {
	    $waiver += (shift @waivers);
	    $report = $$reports{$assgn};
	    $subms = $$report{$login};
	    next if (! defined ($subms) || $#{$subms} < 0);
	    ($timestamp) = ($$subms[$#{$subms}] =~ /^(.*)[SF?]/);
	    $time = TimeStampToTime ($timestamp);
	    $lateness = lateness ($assgn, $login, $time, \$waiver);
	    $sum += $lateness if ($lateness > 0);
	}

	if ($sum > 0) {
	    printf STDOUT "%s: %4.1f\n", $login, $sum;
	}
    }
}

# Usage: report_default \%LATEREPORTS \@ASSGNS
#   Given a hash mapping assignment names in @ASSGNS to late reports (see 
#   readTimesForAssign), print a report to STDOUT in default form.
sub report_default {
    my $reports = shift;
    my $assgns = shift;
    my ($assgn, $login, $item, $timestamp, $time, $type, $subms, $lateness);
    my $firstAssgn;
    my (@waivers, $waiver);
    foreach $login (allLogins ($reports)) {
	$firstAssgn = 1;
	@waivers = @waive;
	$waiver = 0;

	foreach $assgn (@$assgns) {
	    $waiver += (shift @waivers);
	    $report = $$reports{$assgn};
	    $subms = $$report{$login};
	    next if (! defined ($subms) || $#{$subms} < 0);
	    ($timestamp, $type) = ($$subms[$#{$subms}] =~ /^(.*)([SF?])/);
	    $time = TimeStampToTime ($timestamp);
	    $lateness = lateness ($assgn, $login, $time, \$waiver);
	    next if ($lateness <= 0);
	    if ($firstAssgn) {
		print STDOUT "$login:\n";
		$firstAssgn = 0;
	    }
	    printf STDOUT "  %s: %s%s (+%3.1f)\n", 
		$assgn, formatTime ($time), $printed_type{$type}, $lateness;
	}
    }
}

# Rest of main procedure

if (not $opt_X) {
    %deadlineException = GetDeadlineExceptions (1);
}

my ($allTimes, $assgn);

$allTimes = {};

foreach $assgn (@assgn) {
    $$allTimes{$assgn} = readTimesForAssign ($assgn);
}

if ($opt_a) {
    report_a ($allTimes, \@assgn, 1);
} elsif ($opt_A) {
    report_a ($allTimes, \@assgn, 0);
} elsif ($opt_E) {
    report_a ($allTimes, \@assgn, 2);
} elsif ( $opt_s) {
    report_s ($allTimes, \@assgn);
} else {
    report_default ($allTimes, \@assgn);
}

1;
